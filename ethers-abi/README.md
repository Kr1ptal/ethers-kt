# ethers-abi

Module contains the implementation of the [Ethereum ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) with
encoding and decoding logic. The code is optimized for performance by minimizing the number of allocations and copying.
Contract wrapper generation from JSON-ABI is supported by the `abigen` module, which uses the types defined in this
module.

It contains:

- `AbiType`: represents a single elementary type in the ABI specification, e.g. `uint256` or `address[]`. Has support
  for both raw and struct tuples.
- `AbiCodec`: implements the encoding and decoding logic between encoded ABI and JVM types. It also provides support for
  non-standard packed mode.
- `Complex ABI Type Definitions`: `AbiFunction`, `AbiConstructor`, `AbiEvent`, `AbiContract` which provide convenience
  methods for working with elementary ABI types.
- `ContractStruct`, `ContractEvent`, `CustomContractError`: represent actual JVM types for structs, events, and errors. They
  provide a factory and use the ABI type definitions internally to decode the raw data into the actual value.
- `CustomErrorRegistry`: a registry for custom errors which allows to decode the error data into the correct type. By
  default, it only includes the errors generated by `abigen` module, but it can be extended with custom error
  resolvers (e.g. 4byte registry).
- `ContractCall`: a class which represents a call to a contract function. It can be used to encode the call data and
  decode the result data.

`ContractEvent`, `ContractStruct`, and `CustomContractError` represent the actual value, and they have a
corresponding `Factory` type which decodes the raw data into the value. The recommended pattern when implementing these
types is to create a class which represents the value, implementing the type superclass, and implementing the `Factory`
interface on its companion objects.

Event example, a similar pattern applies for structs and errors:

```kotlin
data class Approval(
    val owner: Address,
    val spender: Address,
    val `value`: BigInteger,
    override val log: Log,
) : ContractEvent {
    companion object : EventFactory<Approval> {
        override val abi: AbiEvent = AbiEvent(
            "Approval",
            listOf(
                AbiEvent.Token(AbiType.Address, true),
                AbiEvent.Token(AbiType.Address, true),
                AbiEvent.Token(AbiType.UInt(256), false)
            ),
            false,
        )

        override fun filter(provider: Middleware): EventFilter<Approval> {
            return EventFilter(provider, this)
        }

        override fun decode(log: Log, `data`: Array<Any>): Approval {
            return Approval(
                data[0] as Address,
                data[1] as Address,
                data[2] as BigInteger,
                log,
            )
        }
    }
}
```

## Abi Types <=> JVM Types

- `AbiType.Address` -> `Address`
- `AbiType.FixedBytes` -> `Bytes`
- `AbiType.Bytes` -> `Bytes`
- `AbiType.Int` -> `BigInteger`
- `AbiType.UInt` -> `BigInteger`
- `AbiType.Bool` -> `Boolean`
- `AbiType.String` -> `String`
- `AbiType.FixedArray` -> `Array`
- `AbiType.Array` -> `Array`
- `AbiType.Typle` -> `Array` (raw) / `Class<AbiStruct>` (struct)

## ðŸ’» Code Examples

- Query / listen to decoded contract events (based on event example above):
    ```kotlin
    // query - get the events once
    Approval.filter(provider).topic1(Hash.ZERO).query()
    
    // watch - get the events and listen for new ones using filter polling mechanism
    Approval.filter(provider).topic1(Hash.ZERO).watch()
    
    // subscribe - get the events and listen for new ones using subscription mechanism
    Approval.filter(provider).topic1(Hash.ZERO).subscribe()  
    ```

- Parse function signature and encode/decode call:
    ```kotlin
    val function = AbiFunction.parseSignature(
        "flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16)",
    )
    val params = arrayOf(
        Address("0xdeadeadeadeadeadeadeadeadeadeadeadeadead"),
        arrayOf(Address("0xdeadeadeadeadeadeadeadeadeadeadeadeadead")),
        arrayOf(BigInteger.TEN),
        arrayOf(BigInteger.TEN),
        Address("0xdeadeadeadeadeadeadeadeadeadeadeadeadead"),
        Bytes(byteArrayOf(0, 1, 2, 3, 4, 5)),
        "11424".toBigInteger(),
    )
    
    val encoded = function.encodeCall(params)
    val decoded = function.decodeCall(encoded)
    ```

- Encode data using non-standard packed mode:
    ```kotlin
    val signature = listOf(
        AbiType.FixedArray(1, AbiType.Int(16)),
        AbiType.Int(16),
        AbiType.Bool,
        AbiType.FixedBytes(12),
        AbiType.Bytes,
    )

    val params = arrayOf(
        arrayOf(BigInteger("-5")),
        BigInteger("-5"),
        true,
        Bytes("abcdef124493534081243514"),
        Bytes("abcdef12449353408124351400001240124141941358142723456789876543234567898765432345678909876543456789876543"),
    )

    val encoded = AbiCodec.encodePacked(signature, params)
    ```

